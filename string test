	.globl main
main:				#main has to be a global label
	addu	$s7, $0, $ra	#save the return address in a global register
	.data
buffer:   .space 100
	.globl	prompt 
prompt: .asciiz "\n Enter an expression to calculate. The format will be multiline \n"
prompt_int: .asciiz "\n Enter an Integer \n"
prompt_op: .asciiz "\n Enter an operator or type 'x' to finish\n"
op_done: .asciiz "x"
result: .asciiz "Result is: \n:"
	
    .text
	li	$v0, 4		#print_str (system call 4)
	la	$a0, prompt	# takes the address of the string prompt as an argument 
	syscall 
int_input:
    li $v0, 4
    la $a0, prompt_int
    syscall
    li $v0, 5
    syscall
    #push to stack or heap allocate?
op_input:
	li $v0, 4
    la $a0, prompt_op
    syscall
    li $v0, 12
    syscall
    #push to stack or heap allocate?
    bne $v0, op_done, int_input
heavy_lifting:
	
    
    
	li $v0, 8 #read_string (system call 8)
	la $a0, buffer #
    	li $a1, 20 #what should max length be?
	syscall #a0 contains what you wrote
	
	la $a0, result
	li $v0, 4
	syscall
	
	la $a0, buffer #reload byte space to primary address
	#move $a0,$t0   # primary address = t0 address (load pointer)
	li $v0,4       # print string
	syscall



push:  addi $sp, $sp, -12  # Decrement stack pointer by 12
       sw   $r2, 0($sp)   # Save $r2 to stack
       sw   $r3, 4($sp)   # Save $r3 to stack
       sw   $r4, 8($sp)   # Save $r4 to stack
       
pop:  sw   $r2, 0($sp)   # Copy from stack to $r2
      sw   $r3, 4($sp)   # Copy from stack to $r3
      sw   $r4, 8($sp)   # Copy from stack to $r4
      addi $sp, $sp, 12  # Increment stack pointer by 12
add:
	  add $a0, $a0, $a1  # Add the two inputs
      jr $ra
    
    
li $v0,10      #end program
syscall